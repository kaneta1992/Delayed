<!DOCTYPE html>
<head>
<meta charset="utf-8"/>
</head>

<script id="extractFar" type="x-shader/x-fragment">
#version 300 es
precision highp float;
uniform vec2  resolution;
uniform sampler2D tex;
uniform sampler2D depthNormalTexture;
out vec4 fragColor;

void main( )
{
    vec2 uv = gl_FragCoord.xy / resolution;
    vec2 p = (gl_FragCoord.xy*2.0-resolution)/resolution.y; 

    if (abs(p.y) > 0.75) {
        fragColor=vec4(0.0);
        return;
    }

    float tapDepth = textureLod(depthNormalTexture, uv, 0.0).w;
    vec4 col = textureLod(tex, uv, 0.0);
    if (tapDepth < 15.0) {
        col = vec4(0.0);
    }
    fragColor = col;
}
</script>

<script id="extractNear" type="x-shader/x-fragment">
#version 300 es
precision highp float;
uniform vec2  resolution;
uniform sampler2D tex;
uniform sampler2D depthNormalTexture;
out vec4 fragColor;

void main( )
{
    vec2 uv = gl_FragCoord.xy / resolution;
    vec2 p = (gl_FragCoord.xy*2.0-resolution)/resolution.y; 

    if (abs(p.y) > 0.75) {
        fragColor=vec4(0.0);
        return;
    }

    float tapDepth = textureLod(depthNormalTexture, uv, 0.0).w;
    vec4 col = textureLod(tex, uv, 0.0);
    if (tapDepth > 5.0) {
        col = vec4(0.0);
    }
    fragColor = col;
}
</script>

<script id="DOF" type="x-shader/x-fragment">
#version 300 es
precision highp float;
uniform vec2  resolution;
uniform sampler2D tex;
uniform sampler2D depthNormalTexture;
out vec4 fragColor;

void main( )
{
    vec2 uv = gl_FragCoord.xy / resolution;
    vec2 p = (gl_FragCoord.xy*2.0-resolution)/resolution.y; 
    vec3 col = vec3(0.0);

    if (abs(p.y) > 0.75) {
        fragColor=vec4(col,1);
        return;
    }

    vec3 sum;
    float sumW;

    float depth = textureLod(depthNormalTexture, uv, 0.0).w;

    float center = 10.0;
    float rad = 5.0;
    float smo = 0.0;
    
    float leftTop = center - rad * 0.5;
    float rightTop = center + rad * 0.5;

    float blurIntensity = 1.0 - (smoothstep(leftTop - smo, leftTop, depth) - smoothstep(rightTop, rightTop + smo, depth));

    for(int y=-6;y<=6;++y) {
        for(int x=-6;x<=6;++x) {
            if(x*x+y*y<37)
            {

                vec2 offset=vec2(x,y) / resolution;
                vec2 coord = uv + offset;
                coord.x = clamp(coord.x, 0.001, 0.999);
                coord.y = clamp(coord.y, 0.1255, 0.8745);
                vec4 col = textureLod(tex, coord, 0.0);
                float w = 1.0 * max(col.w, 0.0001);

                sum += col.rgb * w;
                sumW += w; 
            }
        }
    }
    fragColor = vec4(sum / sumW, 1.0);
}
</script>

<script id="DOFCombine" type="x-shader/x-fragment">
#version 300 es
precision highp float;
uniform vec2  resolution;
uniform sampler2D tex;
uniform sampler2D depthNormalTexture;
uniform sampler2D DOFNearTexture;
uniform sampler2D DOFFarTexture;
out vec4 fragColor;

void main( )
{
    vec2 uv = gl_FragCoord.xy / resolution;
    vec2 p = (gl_FragCoord.xy*2.0-resolution)/resolution.y; 
    vec3 col = vec3(0.0);

    if (abs(p.y) > 0.75) {
        fragColor=vec4(col,1);
        return;
    }

    float depth = textureLod(depthNormalTexture, uv, 0.0).w;
    vec4 baseCol = textureLod(tex, uv, 0.0);
    vec4 farCol = textureLod(DOFFarTexture, uv, 0.0);
    vec4 nearCol = textureLod(DOFNearTexture, uv, 0.0);
    baseCol.rgb = mix(baseCol, nearCol, pow(clamp((5.0 - depth), 0.0, 1.0), 1.0)).rgb;
    baseCol.rgb = mix(baseCol, farCol, pow(clamp((depth - 15.0) * 0.05, 0.0, 1.0), 2.0)).rgb;
    fragColor = baseCol;
}
</script>

<script id="copy" type="x-shader/x-fragment">
#version 300 es
precision highp float;
uniform vec2  resolution;
uniform sampler2D tex;
out vec4 fragColor;

void main( )
{
    vec2 uv = gl_FragCoord.xy / resolution;
    fragColor = textureLod(tex, uv, 0.0);
}
</script>

<script id="gaussian" type="x-shader/x-fragment">
#version 300 es
precision highp float;
uniform vec2  resolution;
uniform sampler2D tex; 
uniform vec2 gaussianDir;
out vec4 fragColor;

const float[6] weights = float[](0.200565,0.176998,0.121649,0.0651141,0.0271436,0.00881223);

void main( )
{
    vec2 uv = gl_FragCoord.xy / resolution;

    vec3 center = textureLod(tex, uv, 0.0).rgb;
    vec3 sum = weights[0] * center;
    
    vec2 dir = gaussianDir / resolution;
    for (int i = 1; i < 6; i++) {
        vec2 offset = float(i) * dir;

        vec3 right = textureLod(tex, clamp(uv + offset, 0.0, 1.0), 0.0).rgb;
        vec3 left = textureLod(tex, clamp(uv - offset, 0.0, 1.0), 0.0).rgb;
        sum += weights[i] * right;
        sum += weights[i] * left;
    }

    fragColor=vec4(sum, 1.0);
}
</script>

<script id="blur50" type="x-shader/x-fragment">
#version 300 es
precision highp float;
uniform vec2  resolution;
uniform sampler2D tex;
uniform sampler2D depthNormalTexture;
uniform sampler2D roughnessTexture;
uniform vec2 blurDir;
out vec4 fragColor;

float cosWeight(float i, float power) {
    float c = clamp(i / 20., -1.57, 1.57);
    float w = pow(max(0.f, cos(c)), power);
    return w;
}

void main( )
{
    vec2 uv = gl_FragCoord.xy / resolution;

    vec3 sum = vec3(0.0);
    vec2 dir = blurDir / resolution;
    float wSum = 0.0;

    vec4 centerDepthNormal = textureLod(depthNormalTexture, uv, 0.0);
    float roughness = textureLod(roughnessTexture, uv, 0.0).w;

    vec4 rightDepthNormal;

    for (int i = 0; i <= 20; i++) {
        vec2 offset = float(i) * dir*(roughness * 8.0);

        rightDepthNormal = textureLod(depthNormalTexture, clamp(uv + offset, 0.0, 1.0), 0.0);
        vec4 leftDepthNormal = textureLod(depthNormalTexture, clamp(uv - offset, 0.0, 1.0), 0.0);

        vec3 right = textureLod(tex, clamp(uv + offset, 0.0, 1.0), 0.0).rgb;
        vec3 left = textureLod(tex, clamp(uv - offset, 0.0, 1.0), 0.0).rgb;

        float rightnw = max(0.001, pow(abs(dot(rightDepthNormal.xyz, centerDepthNormal.xyz)), 8.0));
        float leftnw = max(0.001, pow(abs(dot(leftDepthNormal.xyz, centerDepthNormal.xyz)), 8.0));

        float rightr2 = (rightDepthNormal.w - centerDepthNormal.w) * 1.0;
        float rightg = exp(-rightr2*rightr2);

        float leftr2 = (leftDepthNormal.w - centerDepthNormal.w) * 1.0;
        float leftg = exp(-leftr2*leftr2);

        float w = cosWeight(float(i), 1.0);
        wSum += w * rightg * rightnw + w * leftg * leftnw;
        sum += w * right * rightg * rightnw;
        sum += w * left * leftg * leftnw;
    }

    fragColor=vec4(sum / wSum, 1.0);
}
</script>

<script id="sumBloom" type="x-shader/x-fragment">
#version 300 es
precision highp float;
uniform vec2  resolution;
uniform sampler2D tex1;
uniform sampler2D tex2;
uniform sampler2D tex3;
uniform sampler2D tex4;
uniform sampler2D tex5;
out vec4 fragColor;

void main( )
{
    vec2 uv = (gl_FragCoord.xy) / resolution;
    float intensity = 0.015;
    vec3 sum = textureLod(tex1, uv, 0.0).rgb * intensity * 1.0;
    sum += textureLod(tex2, uv, 0.0).rgb * intensity * 2.0;
    sum += textureLod(tex3, uv, 0.0).rgb * intensity * 4.0;
    sum += textureLod(tex4, uv, 0.0).rgb * intensity * 8.0;
    sum += textureLod(tex5, uv, 0.0).rgb * intensity * 16.0;
    fragColor=vec4(sum, 1.0);
}
</script>

<script id="mainHeader" type="x-shader/x-fragment">
#version 300 es
precision highp float;
uniform vec2 fullResolution;
uniform vec2  iResolution; 
uniform float iTime;
uniform sampler2D reflectTexture;
uniform sampler2D depthNormalTexture;
uniform sampler2D roughnessTexture;

layout (location = 0) out vec4 fragColor;
layout (location = 1) out vec4 fragColor2;

#define MAT_INSIDE  0.
#define MAT_OUTSIDE 1.
#define MAT_PILLAR  2.
#define MAT_BOARD   3.
#define MAT_LIGHT   4.

float sphere(vec3 p, float s) {
    return length(p) - s;
}

float rBox( vec3 p, vec3 b, float r ){
    vec3 q = abs(p) - b;
    return length(max(q,0.0)) + min(max(q.x,max(q.y,q.z)),0.0) - r;
}

float cylinder(vec3 p, float r, float h) {
    float d = length(p.xz) - r;
    float clip = abs(p.y) - h;
    return max(d, clip);
}

vec3 boardOffset;
float boardDistance(vec3 p, vec3 offset) {
    boardOffset = offset;
    p -= offset;
    vec3 connectionPos = p;
    connectionPos.x = abs(connectionPos.x) - 0.5;
    connectionPos.y -= 2.0;
    
    float d = cylinder(connectionPos, 0.025, 2.0);
    d = min(d, rBox(p, vec3(0.8, 0.3, 0.05), 0.05));
    return d;
}

float lightsDistance(vec3 p) {
    p.z = mod(p.z + 3.0, 6.0) - 3.0;
    p.x = abs(p.x) - 1.0;
    float d = rBox(p, vec3(0.1, 0.001, 1.5), 0.02);
    return d;
}

vec2 min2(vec2 a, vec2 b) {
    return a.x < b.x ? a : b;
}

vec2 max2(vec2 a, vec2 b) {
    return a.x > b.x ? a : b;
}

vec2 map(vec3 p) {
    vec2 floorPos = p.xy;
    floorPos = abs(floorPos) - vec2(5.0, 1.5);
    vec2 flor = vec2(-max(floorPos.x, floorPos.y), MAT_INSIDE);
    
    vec3 pillarPos = p;
    pillarPos.x = abs(pillarPos.x) - 2.5;
    pillarPos.z = mod(pillarPos.z + 2.5, 5.0) - 2.5;
    vec2 pillar = vec2(rBox(pillarPos, vec3(0.2, 4.0, 0.2), 0.05), MAT_PILLAR);
    
    vec2 substractBoxPos = p.xy;
    substractBoxPos.x = abs(substractBoxPos.x) - 7.0;
    substractBoxPos = abs(substractBoxPos) - vec2(3.0, 4.0);
    vec2 substractBox = vec2(-max(substractBoxPos.x, substractBoxPos.y), MAT_OUTSIDE);
    
    vec2 d = min2(pillar, flor);
    d = max2(d, substractBox);
    
    vec3 boardPos = p;
    
    boardPos.z = mod(boardPos.z + 10.0, 20.0) - 10.0;
    vec2 board = vec2(boardDistance(boardPos, vec3(0.0, 1.0, 0.0)), MAT_BOARD);
    d = min2(d, board);

    vec3 target = vec3(0.0, -0.5, iTime + 4.0);
    d = min2(d, vec2(sphere(p - target, 0.3), MAT_LIGHT));

    p.y -= 1.5;
    vec2 lights = vec2(lightsDistance(p), MAT_LIGHT);
    
    d = min2(d, lights);

    
    return d;
}

vec3 hash(vec2 p)
{
	vec3 p3 = fract(vec3(p.xyx) * vec3(.1031, .1030, .0973));
    p3 += dot(p3, p3.yxz+33.33);
    return fract((p3.xxy+p3.yzz)*p3.zyx);
}

vec3 noised( in vec2 x )
{
    vec2 p = floor(x);
    vec2 f = fract(x);
    vec2 u = f*f*(3.0-2.0*f);
	float a = hash(p+vec2(0.5,0.5)).x;
	float b = hash(p+vec2(1.5,0.5)).x;
	float c = hash(p+vec2(0.5,1.5)).x;
	float d = hash(p+vec2(1.5,1.5)).x;
	return vec3(a+(b-a)*u.x+(c-a)*u.y+(a-b-c+d)*u.x*u.y,
				6.0*f*(1.0-f)*(vec2(b-a,c-a)+(a-b-c+d)*u.yx));
}

const int NOISE_OCTAVES = 7;

float elevated(vec2 p)
{
	const mat2 m2 = mat2(0.8,-0.6,0.6,0.8);
    
    p = p*3.0+vec2(10.0,-1.0);
    
    float a = 0.0;
    float b = 1.0;
	vec2  d = vec2(0.0);
    for( int i=0; i<NOISE_OCTAVES; i++ )
    {
        vec3 n = noised(p);
        d += n.yz;
        a += b*n.x/(1.0+dot(d,d));
		b *= 0.5;
        p = m2*p*2.0;
    }
    return a;
}

float tileOffset(vec3 p) {
    float pattern = elevated(p.xz*0.5);
    return pattern;
}

vec3 normal2( in vec3 pos, float eps )
{
    vec2 e = vec2(1.0,-1.0)*0.5773*eps;
    float intensity = 0.005;
    vec3 p1 = pos * 1.0 + e.xyy;
    vec3 p2 = pos * 1.0 + e.yyx;
    vec3 p3 = pos * 1.0 + e.yxy;
    vec3 p4 = pos * 1.0 + e.xxx;


    float n1 = tileOffset(p1) * intensity;
    float n2 = tileOffset(p2) * intensity;
    float n3 = tileOffset(p3) * intensity;
    float n4 = tileOffset(p4) * intensity;
    return normalize( e.xyy*(map( pos + e.xyy ).x + n1) +
					  e.yyx*(map( pos + e.yyx ).x + n2) +
					  e.yxy*(map( pos + e.yxy ).x + n3) +
					  e.xxx*(map( pos + e.xxx ).x + n4) );
}

vec3 normal3( in vec3 pos, float eps )
{
    vec2 e = vec2(1.0,-1.0)*0.5773*eps;
    return normalize( e.xyy*(map( pos + e.xyy ).x) +
					  e.yyx*(map( pos + e.yyx ).x) +
					  e.yxy*(map( pos + e.yxy ).x) +
					  e.xxx*(map( pos + e.xxx ).x) );
}

void ceilProperty(vec3 p, vec2 mat, out vec3 baseColor, out float roughness) {
    vec3 q = p;
    p.z = mod(p.z + 0.15, 0.3) - 0.15;
    p.z = abs(p.z);
    float t = smoothstep(0.001, 0.015, p.z);
    baseColor = vec3(mix(vec3(0.49), vec3(0.5, 0.5, 0.5), t));
    roughness = mix(0.6, pow(tileOffset(q*0.5), 2.0) * 0.3, smoothstep(0.001, 0.015, p.z));
}

void floorProperty(vec3 p, vec2 mat, out vec3 baseColor, out float roughness) {
    vec2 latticePos = p.xz;
    latticePos = mod(latticePos + 0.15, 0.3) - 0.15;
    latticePos = abs(latticePos);
    float latticeAlpha = smoothstep(0.001, 0.015, min(latticePos.x, latticePos.y));
    
    vec2 blockPos = p.xz;
    blockPos.x = abs(blockPos.x) - 3.5; // block interval
    blockPos.x = abs(blockPos.x) - 0.2; // block width
    float blockAlpha = smoothstep(0.006, 0.001, blockPos.x);
    
    
    baseColor = vec3(mix(vec3(0.4), vec3(0.5, 0.5, 0.5), latticeAlpha));
    baseColor = vec3(mix(baseColor, vec3(0.6, 0.5, 0.1), blockAlpha));

    roughness = mix(0.8, pow(tileOffset(p*2.), 2.0) * 0.6, smoothstep(0.001, 0.03, min(latticePos.x, latticePos.y)));
    roughness = mix(roughness, 1.0, blockAlpha);
    roughness = clamp(roughness, 0.0, 1.0);
    //roughness = tileOffset(p * 1.);
}

void pillarProperty(vec3 p, vec2 mat, out vec3 baseColor, out float roughness) {
    vec3 pillarPos = p;
    pillarPos.y = mod(pillarPos.y + 0.4, 0.8) - 0.4;
    float d = abs(pillarPos.y);
    float pillarAlpha = smoothstep(0.001, 0.006, d);

    baseColor = vec3(mix(vec3(0.2), vec3(0.5, 0.5, 0.5), pillarAlpha));

    roughness = mix(1.0, 0.2, pillarAlpha);
}

void outsideProperty(vec3 p, vec2 mat, out vec3 baseColor, out float roughness) {
    baseColor = vec3(0.05, 0.02, 0.005)*3000.0;
    roughness = 0.2;
}

void boardProperty(vec3 p, vec2 mat, out vec3 baseColor, out float roughness) {
    p -= boardOffset;
    vec2 displayPos = p.xy;
    displayPos.y = abs(displayPos.y + 0.08) - 0.1;
    displayPos = abs(displayPos) - vec2(0.7, 0.08);
    
    float d = max(displayPos.x, displayPos.y);
    float displayAlpha = smoothstep(0.006, 0.001, d);
    
    baseColor = mix(vec3(0.02), vec3(0.005), displayAlpha);
    roughness = mix(0.4, 0.0, displayAlpha);
}

void materialToProperty(vec3 p, vec2 mat, out vec3 baseColor, out vec3 normalVec, out float roughness) {
    baseColor = vec3(0.0);
    roughness = 0.0;
    if (mat.y == MAT_INSIDE) {
        if (p.y < 0.0) {
            // floor
            floorProperty(p, mat, baseColor, roughness);
        } else {
            // ceil
            ceilProperty(p, mat, baseColor, roughness);
        }
    } else if (mat.y == MAT_OUTSIDE) {
        outsideProperty(p, mat, baseColor, roughness);
    } else if (mat.y == MAT_PILLAR) {
        pillarProperty(p, mat, baseColor, roughness);
    } else if (mat.y == MAT_BOARD) {
        boardProperty(p, mat, baseColor, roughness);
    } else if (mat.y == MAT_LIGHT) {
        baseColor = vec3(30.0);
    }
    normalVec = normal2(p, 0.0005);
}

void raymarch(vec3 origin, vec3 ray, int iter, out vec3 pos, out vec2 mat, out float t) {
    t = 0.01;
    vec3 col = vec3(0.0);
    int i;
    for(i=0; i<iter; i++) {
        pos = origin + ray * t;
        mat = map(pos);
        if (mat.x < 0.001) {
            break;
        }
        t += mat.x;
    }
}

vec3 shade(vec3 p, vec3 baseColor, float t) {
    p.x = abs(p.x) - 1.0;
    float attenuation = 1.0 / (pow(abs(p.x), 2.0) + pow(abs(p.y + 1.5), 2.) + 6.0);
    vec3 col = baseColor * vec3(5.0) * attenuation;
    col = mix( col, vec3(0.0), 1.0-exp(-t*0.03) );
    return col;
}

float remap(float val, float inMin, float inMax, float outMin, float outMax)
{
    return clamp(outMin + (val - inMin) * (outMax - outMin) / (inMax - inMin), outMin, outMax);
}

vec3 EnvBRDFApprox( vec3 SpecularColor, float Roughness, float NoV )
{
	const vec4 c0 = vec4( -1, -0.0275, -0.572, 0.022 );
	const vec4 c1 = vec4( 1, 0.0425, 1.04, -0.04 );
	vec4 r = Roughness * c0 + c1;
	float a004 = min( r.x * r.x, exp2( -9.28 * NoV ) ) * r.x + r.y;
	vec2 AB = vec2( -1.04, 1.04 ) * a004 + r.zw;
	return SpecularColor * AB.x + AB.y;
}

vec3 fresnelSchlick_roughness(vec3 F0, float cosTheta, float roughness) {
    return F0 + (max(vec3(1.0 - roughness), F0) - F0) * pow(1.0 - cosTheta, 5.0);
}

vec3 shadeWithReflect(vec3 p, vec3 ray, vec2 uv, vec3 baseColor, float t, vec3 n) {
    vec3 n2 = n - normal3(p, 0.0005);
    p.x = abs(p.x) - 1.0;
    float attenuation = 1.0 / (pow(abs(p.x), 2.0) + pow(abs(p.y + 1.5), 2.) + 6.0);
    vec3 col = baseColor * vec3(5.0) * attenuation;

    float roughness = textureLod(roughnessTexture, uv, 0.0).w;
    //roughness = 0.0;
    vec3 F  = fresnelSchlick_roughness(vec3(0.04), max(dot(n, -ray), 0.0), roughness);
    vec3 ref = EnvBRDFApprox(vec3(0.0000), roughness, max(dot(n, -ray), 0.0));
    
    float adjust = remap(1.0 - (t / 20.0), 0.0, 1.0, 0.1, 1.0);
    col += textureLod(reflectTexture, uv + n2.xz*adjust*0.15, 0.0).rgb * F;
    col = mix( col, vec3(0.0), 1.0-exp(-t*0.03) );
    return col;
}

void getCamera(vec2 p, out vec3 origin, out vec3 ray) {
    origin = vec3(sin(iTime*0.2) * 7.0, cos(iTime*0.05)*1., -5.0 + iTime);
    vec3 target = vec3(0.0, -0.5, iTime);
    vec3 fo = normalize(target - origin);
    vec3 si = normalize(cross(vec3(0.0, 1.0, 0.0), fo));
    vec3 up = normalize(cross(fo, si));
    ray = normalize(fo * 3.5 + si * p.x + up * p.y);
}

</script>

<script id="GBuffer" type="x-shader/x-fragment">
void mainImage( out vec4 fragColor, out vec4 fragColor2, in vec2 fragCoord ) {
    vec2 p = (fragCoord.xy * 2.0 - iResolution.xy) / min(iResolution.x, iResolution.y);
    vec2 uv = fragCoord.xy / iResolution.xy;
        
    if (abs(p.y) > 0.75) {
        return;
    }
    vec3 origin, ray;
    getCamera(p, origin, ray);

    vec3 col, pos;
    vec2 d;
    float t, roughness;
    vec3 baseColor, n;
    raymarch(origin, ray, 128, pos, d, t);
    materialToProperty(pos, d, baseColor, n, roughness);

    fragColor  = vec4(n, t);
    fragColor2 = vec4(d, 1.0, roughness);
}

void main( )
{
    vec4 col, col2;
    mainImage(col, col2, gl_FragCoord.xy);
    fragColor  = col;
    fragColor2 = col2;
}
</script>

<script id="main" type="x-shader/x-fragment">
void mainImage( out vec4 fragColor, in vec2 fragCoord ) {
    vec2 p = (fragCoord.xy * 2.0 - iResolution.xy) / min(iResolution.x, iResolution.y);
    vec2 uv = fragCoord.xy / iResolution.xy;
        
    if (abs(p.y) > 0.75) {
        return;
    }
    vec3 origin, ray;
    getCamera(p, origin, ray);

    vec3 col, pos;
    vec2 d;
    float t, roughness;
    vec3 baseColor, n;
    vec4 depthNormal = textureLod(depthNormalTexture, uv, 0.0);
    vec4 matRoughness = textureLod(roughnessTexture, uv, 0.0);
    t = depthNormal.w;
    d = matRoughness.xy;
    pos = origin + ray * t;

    materialToProperty(pos, d, baseColor, n, roughness);

    vec3 primaryCol = shadeWithReflect(pos, ray, uv, baseColor, t, n);
    col = primaryCol;
    fragColor = vec4(col,1.0);
}

void main( )
{
    vec4 col;
    mainImage(col, gl_FragCoord.xy);
    fragColor  = col;
}
</script>

<script id="mainReflect" type="x-shader/x-fragment">
void mainImage( out vec4 fragColor, in vec2 fragCoord ) {
    vec2 p = (fragCoord.xy * 2.0 - iResolution.xy) / min(iResolution.x, iResolution.y);
    vec2 uv = gl_FragCoord.xy / iResolution;
        
    if (abs(p.y) > 0.75) {
        return;
    }
    vec3 origin, ray;
    getCamera(p, origin, ray);

    vec3 col, pos;
    vec2 d;
    float t, roughness;
    vec3 baseColor, n;
    vec4 depthNormal = textureLod(depthNormalTexture, uv, 0.0);
    vec4 matRoughness = textureLod(roughnessTexture, uv, 0.0);
    t = depthNormal.w;
    d = matRoughness.xy;
    pos = origin + ray * t;

    materialToProperty(pos, d, baseColor, n, roughness);

    n = normal3(pos, 0.005);
    vec3 r = reflect(ray, n);
    
    raymarch(pos + n*0.1, r, 64, pos, d, t);
    materialToProperty(pos, d, baseColor, n, roughness);
    
    vec3 secondaryCol = shade(pos, baseColor, t);
    
    col = secondaryCol;

    fragColor = vec4(col,1.0);
}

void main( )
{
    vec4 col;
    mainImage(col, gl_FragCoord.xy);
    fragColor = col;
}
</script>

<script id="fs" type="x-shader/x-fragment">
#version 300 es
precision highp float;
uniform vec2 fullResolution;
uniform vec2  resolution; 
uniform float time;
uniform sampler2D tex;

out vec4 fragColor;

void main( )
{
    vec2 p = (gl_FragCoord.xy*2.0-resolution)/resolution.y;
    vec2 uv = gl_FragCoord.xy / resolution;
    vec3 col = vec3(p, 0.5);
    vec2 rate = fullResolution / vec2(1024.0f);

    uv.y = 1.0 - uv.y;
    uv = uv * rate;

    col = textureLod(tex, clamp(uv, 0.0, 1.0), 0.0).rgb;
    fragColor=vec4(col,1);
}
</script>

<script id="combine" type="x-shader/x-fragment">
#version 300 es
precision highp float;
uniform vec2  resolution;
uniform sampler2D tex;
uniform sampler2D bloomTex;
out vec4 fragColor;

float luminance(vec3 col)
{
    return dot(vec3(0.298912, 0.586611, 0.114478), col);
}

vec3 saturation(vec3 col, float scale)
{
    return mix(vec3(luminance(col)), col, scale);
}

vec3 contrast(vec3 col, float scale)
{
    return (col - 0.5) * scale + 0.5;
}

vec3 colorCollect(vec3 col) {
    col = saturation(col, 0.5);
    col = pow(col, vec3(1.5));
    //col = contrast(col, 1.5);
    //col = col * vec3(1.0, 1.2, 1.5);
    //col = col * vec3(1.0, 1.5, 2.0);
    col = col * vec3(0.6, 0.9, 1.0);
    //col = col * vec3(0.7, 1.0, 0.8);
    return col;
}

vec3 acesFilm(const vec3 x) {
    const float a = 2.51;
    const float b = 0.03;
    const float c = 2.43;
    const float d = 0.59;
    const float e = 0.14;
    return clamp((x * (a * x + b)) / (x * (c * x + d ) + e), 0.0, 1.0);
}

// https://www.shadertoy.com/view/MdfBRX
float Bokeh(vec2 p, vec2 sp, float size, float mi, float blur)
{
    float d = length(p - sp);
    float c = smoothstep(size, size*(1.-blur), d);
    c *= mix(mi, 1., smoothstep(size*.8, size, d));
    return c;
}

vec2 hash( vec2 p ){
    p = vec2( dot(p,vec2(127.1,311.7)),dot(p,vec2(269.5,183.3)));
    return fract(sin(p)*43758.5453) * 2.0 - 1.0;
}

vec3 dirt(vec2 uv, float n)
{
    vec2 p = fract(uv * n);
    vec2 st = (floor(uv * n) + 0.5) / n;
    vec2 rnd = hash(st);
    float c = Bokeh(p, vec2(0.5, 0.5) + vec2(0.3) * rnd, 0.2, abs(rnd.y * 0.4) + 0.3, 0.25 + rnd.x * rnd.y * 0.2);
    
    return vec3(c) * exp(rnd.x * 4.0);
}

vec3 dirtTexture(vec2 uv) {
    uv *= 2.5;
    vec3 di = vec3(0.0);
    di += dirt(uv - vec2(0.17), 60.0);
    di += dirt(uv - vec2(0.17), 30.0);
    di += dirt(uv - vec2(0.41), 100.75);
    di += dirt(uv - vec2(0.41), 20.75);
    return di * 0.01;
}

void main( )
{
    vec2 p = (gl_FragCoord.xy*2.0-resolution)/resolution.y; 
    vec2 uv = gl_FragCoord.xy / resolution;
    vec3 col = vec3(0.0);

    if (abs(p.y) > 0.75) {
        fragColor=vec4(col,1);
        return;
    }

    vec3 bloom = textureLod(bloomTex, clamp(uv, 0.0, 1.0), 0.0).rgb;
    col = textureLod(tex, uv, 0.0).rgb + bloom;

    vec2 dirtuv = gl_FragCoord.xy / min(resolution.x, resolution.y);
    col +=  pow(bloom, vec3(1.5)) * dirtTexture(dirtuv);
    col = colorCollect(col);
    col = acesFilm(col*0.3);
    col = pow(col, vec3(1.0/2.2));
    //col = colorCollect(col);

    vec3 sclr = smoothstep(0.0, 1.0, col.rgb);

    col.r = mix(col.r, sclr.r, 1.0);
    col.g = mix(col.g, sclr.g, 0.8);
    col.b = mix(col.b, sclr.b, 0.6);

    //col = bloom*0.5;
    //col = vec3(textureLod(tex, clamp(uv, 0.0, 1.0), 0.0).rgb);
    
    p = gl_FragCoord.xy / resolution;
    p *=  1.0 - p.yx;
    float vig = p.x*p.y * 30.0;
    vig = clamp(pow(vig, 0.2), 0.0, 1.0);    

    fragColor=vec4(col*vig,1);
}
</script>

<script id="postProcess" type="x-shader/x-fragment">
#version 300 es
precision highp float;
uniform vec2  resolution;
uniform sampler2D tex;
out vec4 fragColor;

void main( )
{
    vec2 p = (gl_FragCoord.xy*2.0-resolution)/resolution.y; 
    vec2 uv = gl_FragCoord.xy / resolution;
    vec3 col = vec3(0.0);

    if (abs(p.y) > 0.75) {
        fragColor=vec4(col,1);
        return;
    }

    p = (gl_FragCoord.xy*2.0-resolution)/resolution.xy; 
    vec2 uvR = (p+p*dot(p, p)*0.01) * 0.5 + 0.5;
    vec2 uvG = (p+p*dot(p, p)*0.02) * 0.5 + 0.5;
    vec2 uvB = (p+p*dot(p, p)*0.03) * 0.5 + 0.5;

    float r = textureLod(tex, uvR, 0.0).r;
    float g = textureLod(tex, uvG, 0.0).g;
    float b = textureLod(tex, uvB, 0.0).b;

    col = vec3(r,g,b);
    
    p = gl_FragCoord.xy / resolution;
    p *=  1.0 - p.yx;
    float vig = p.x*p.y * 30.0;
    vig = clamp(pow(vig, 0.2), 0.0, 1.0);    

    fragColor=vec4(col*vig,1);
}
</script>

<link rel="stylesheet" href="./style.css" />

<script type="text/javascript" src="http://ajax.googleapis.com/ajax/libs/webfont/1/webfont.js"></script>
<script type="text/javascript" src="./utility.js"></script>
<script type="text/javascript" src="./app.js"></script>

<html>
    <body>

    </body>
</html>