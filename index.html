<!DOCTYPE html>
<head>
<meta charset="utf-8"/>
</head>

<script id="copy" type="x-shader/x-fragment">
#version 300 es
precision highp float;
uniform vec2  resolution;
uniform sampler2D tex;
out vec4 fragColor;

void main( )
{
    vec2 uv = gl_FragCoord.xy / resolution;
    fragColor = textureLod(tex, uv, 0.0);
}
</script>

<script id="gaussian" type="x-shader/x-fragment">
#version 300 es
precision highp float;
uniform vec2  resolution;
uniform sampler2D tex; 
uniform vec2 gaussianDir;
out vec4 fragColor;

const float[6] weights = float[](0.200565,0.176998,0.121649,0.0651141,0.0271436,0.00881223);

void main( )
{
    vec2 uv = gl_FragCoord.xy / resolution;

    vec3 center = textureLod(tex, uv, 0.0).rgb;
    vec3 sum = weights[0] * center;
    
    vec2 dir = gaussianDir / resolution;
    for (int i = 1; i < 6; i++) {
        vec2 offset = float(i) * dir;

        vec3 right = textureLod(tex, clamp(uv + offset, 0.0, 1.0), 0.0).rgb;
        vec3 left = textureLod(tex, clamp(uv - offset, 0.0, 1.0), 0.0).rgb;
        sum += weights[i] * right;
        sum += weights[i] * left;
    }

    fragColor=vec4(sum, 1.0);
}
</script>

<script id="blur50" type="x-shader/x-fragment">
#version 300 es
precision highp float;
uniform vec2  resolution;
uniform sampler2D tex;
uniform sampler2D depthNormalTexture;
uniform sampler2D roughnessTexture;
uniform vec2 blurDir;
out vec4 fragColor;

float cosWeight(float i, float power) {
    float c = clamp(i / 20., -1.57, 1.57);
    float w = pow(max(0.f, cos(c)), power);
    return w;
}

void main( )
{
    vec2 uv = gl_FragCoord.xy / resolution;

    vec3 sum = vec3(0.0);
    vec2 dir = blurDir / resolution;
    float wSum = 0.0;

    vec4 centerDepthNormal = textureLod(depthNormalTexture, uv, 0.0);
    float roughness = textureLod(roughnessTexture, uv, 0.0).w;

    vec4 rightDepthNormal;

    for (int i = 0; i <= 50; i++) {
        vec2 offset = float(i) * dir*(roughness * 2.5);

        rightDepthNormal = textureLod(depthNormalTexture, clamp(uv + offset, 0.0, 1.0), 0.0);
        vec4 leftDepthNormal = textureLod(depthNormalTexture, clamp(uv - offset, 0.0, 1.0), 0.0);

        vec3 right = textureLod(tex, clamp(uv + offset, 0.0, 1.0), 0.0).rgb;
        vec3 left = textureLod(tex, clamp(uv - offset, 0.0, 1.0), 0.0).rgb;

        float rightnw = max(0.001, pow(abs(dot(rightDepthNormal.xyz, centerDepthNormal.xyz)), 8.0));
        float leftnw = max(0.001, pow(abs(dot(leftDepthNormal.xyz, centerDepthNormal.xyz)), 8.0));

        float rightr2 = (rightDepthNormal.w - centerDepthNormal.w) * 1.0;
        float rightg = exp(-rightr2*rightr2);

        float leftr2 = (leftDepthNormal.w - centerDepthNormal.w) * 1.0;
        float leftg = exp(-leftr2*leftr2);

        float w = cosWeight(float(i), 1.0);
        wSum += w * rightg * rightnw + w * leftg * leftnw;
        sum += w * right * rightg * rightnw;
        sum += w * left * leftg * leftnw;
    }

    fragColor=vec4(sum / wSum, 1.0);
}
</script>

<script id="sumBloom" type="x-shader/x-fragment">
#version 300 es
precision highp float;
uniform vec2  resolution;
uniform sampler2D tex1;
uniform sampler2D tex2;
uniform sampler2D tex3;
uniform sampler2D tex4;
uniform sampler2D tex5;
out vec4 fragColor;

void main( )
{
    vec2 uv = (gl_FragCoord.xy) / resolution;
    float intensity = 0.015;
    vec3 sum = textureLod(tex1, uv, 0.0).rgb * intensity * 1.0;
    sum += textureLod(tex2, uv, 0.0).rgb * intensity * 2.0;
    sum += textureLod(tex3, uv, 0.0).rgb * intensity * 4.0;
    sum += textureLod(tex4, uv, 0.0).rgb * intensity * 8.0;
    sum += textureLod(tex5, uv, 0.0).rgb * intensity * 16.0;
    fragColor=vec4(sum, 1.0);
}
</script>

<script id="mainHeader" type="x-shader/x-fragment">
#version 300 es
precision highp float;
uniform vec2 fullResolution;
uniform vec2  iResolution; 
uniform float iTime;
uniform sampler2D reflectTexture;
uniform sampler2D depthNormalTexture;
uniform sampler2D roughnessTexture;

layout (location = 0) out vec4 fragColor;
layout (location = 1) out vec4 fragColor2;

#define MAT_INSIDE  0.
#define MAT_OUTSIDE 1.
#define MAT_PILLAR  2.
#define MAT_BOARD   3.
#define MAT_LIGHT   4.

float sphere(vec3 p, float s) {
    return length(p) - s;
}

float rBox( vec3 p, vec3 b, float r ){
    vec3 q = abs(p) - b;
    return length(max(q,0.0)) + min(max(q.x,max(q.y,q.z)),0.0) - r;
}

float cylinder(vec3 p, float r, float h) {
    float d = length(p.xz) - r;
    float clip = abs(p.y) - h;
    return max(d, clip);
}

vec3 boardOffset;
float boardDistance(vec3 p, vec3 offset) {
    boardOffset = offset;
    p -= offset;
    vec3 connectionPos = p;
    connectionPos.x = abs(connectionPos.x) - 0.5;
    connectionPos.y -= 2.0;
    
    float d = cylinder(connectionPos, 0.025, 2.0);
    d = min(d, rBox(p, vec3(0.8, 0.3, 0.05), 0.05));
    return d;
}

float lightsDistance(vec3 p) {
    p.z = mod(p.z + 3.0, 6.0) - 3.0;
    p.x = abs(p.x) - 1.0;
    float d = rBox(p, vec3(0.1, 0.001, 1.5), 0.02);
    return d;
}

vec2 min2(vec2 a, vec2 b) {
    return a.x < b.x ? a : b;
}

vec2 max2(vec2 a, vec2 b) {
    return a.x > b.x ? a : b;
}

vec2 map(vec3 p) {
    vec2 floorPos = p.xy;
    floorPos = abs(floorPos) - vec2(5.0, 1.5);
    vec2 flor = vec2(-max(floorPos.x, floorPos.y), MAT_INSIDE);
    
    vec3 pillarPos = p;
    pillarPos.x = abs(pillarPos.x) - 2.5;
    pillarPos.z = mod(pillarPos.z + 2.5, 5.0) - 2.5;
    vec2 pillar = vec2(rBox(pillarPos, vec3(0.2, 4.0, 0.2), 0.05), MAT_PILLAR);
    
    vec2 substractBoxPos = p.xy;
    substractBoxPos.x = abs(substractBoxPos.x) - 7.0;
    substractBoxPos = abs(substractBoxPos) - vec2(3.0, 4.0);
    vec2 substractBox = vec2(-max(substractBoxPos.x, substractBoxPos.y), MAT_OUTSIDE);
    
    vec2 d = min2(pillar, flor);
    d = max2(d, substractBox);
    
    vec3 boardPos = p;
    
    boardPos.z = mod(boardPos.z + 10.0, 20.0) - 10.0;
    vec2 board = vec2(boardDistance(boardPos, vec3(0.0, 1.0, 0.0)), MAT_BOARD);
    d = min2(d, board);

    vec3 target = vec3(0.0, -0.5, iTime + 4.0);
    d = min2(d, vec2(sphere(p - target, 0.3), MAT_LIGHT));

    p.y -= 1.5;
    vec2 lights = vec2(lightsDistance(p), MAT_LIGHT);
    
    d = min2(d, lights);

    
    return d;
}

void ceilProperty(vec3 p, vec2 mat, out vec3 baseColor) {
    p.z = mod(p.z + 0.15, 0.3) - 0.15;
    p.z = abs(p.z);
    float t = smoothstep(0.001, 0.006, p.z);
    baseColor = vec3(mix(vec3(0.2), vec3(0.5, 0.5, 0.5), t));
}

void floorProperty(vec3 p, vec2 mat, out vec3 baseColor) {
    vec2 latticePos = p.xz;
    latticePos = mod(latticePos + 0.15, 0.3) - 0.15;
    latticePos = abs(latticePos);
    float latticeAlpha = smoothstep(0.001, 0.006, min(latticePos.x, latticePos.y));
    
    vec2 blockPos = p.xz;
    blockPos.x = abs(blockPos.x) - 3.5; // block interval
    blockPos.x = abs(blockPos.x) - 0.2; // block width
    float blockAlpha = smoothstep(0.006, 0.001, blockPos.x);
    
    
    baseColor = vec3(mix(vec3(0.2), vec3(0.5, 0.5, 0.5), latticeAlpha));
    baseColor = vec3(mix(baseColor, vec3(0.6, 0.5, 0.1), blockAlpha));
}

void pillarProperty(vec3 p, vec2 mat, out vec3 baseColor) {
    vec3 pillarPos = p;
    pillarPos.y = mod(pillarPos.y + 0.4, 0.8) - 0.4;
    float d = abs(pillarPos.y);
    float pillarAlpha = smoothstep(0.001, 0.006, d);

    baseColor = vec3(mix(vec3(0.2), vec3(0.5, 0.5, 0.5), pillarAlpha));
}

void outsideProperty(vec3 p, vec2 mat, out vec3 baseColor) {
    baseColor = vec3(0.05, 0.02, 0.005);
}

void boardProperty(vec3 p, vec2 mat, out vec3 baseColor) {
    p -= boardOffset;
    vec2 displayPos = p.xy;
    displayPos.y = abs(displayPos.y + 0.08) - 0.1;
    displayPos = abs(displayPos) - vec2(0.7, 0.08);
    
    float d = max(displayPos.x, displayPos.y);
    float displayAlpha = smoothstep(0.006, 0.001, d);
    
    baseColor = mix(vec3(0.02), vec3(0.005), displayAlpha);
}

float hash( float n )
{
    return fract(sin(n)*43758.5453);
}

float noise( in vec3 x )
{
    vec3 p = floor(x);
    vec3 f = fract(x);

    f = f*f*(3.0-2.0*f);

    float n = p.x + p.y*57.0 + 113.0*p.z;

    float res = mix(mix(mix( hash(n+  0.0), hash(n+  1.0),f.x),
                        mix( hash(n+ 57.0), hash(n+ 58.0),f.x),f.y),
                    mix(mix( hash(n+113.0), hash(n+114.0),f.x),
                        mix( hash(n+170.0), hash(n+171.0),f.x),f.y),f.z);
    return res;
}

mat3 m = mat3( 0.00,  0.80,  0.60,
              -0.80,  0.36, -0.48,
              -0.60, -0.48,  0.64 );


float fbm( vec3 pos )
{
    float o = 0.;
    for ( int i=0; i < 5; i++ )
    {
    	o = o*2. + noise(pos);
        pos = m * pos * 2.;
    }
    return o / 40.0;
}

vec3 normal2( in vec3 pos, float eps )
{
    vec2 e = vec2(1.0,-1.0)*0.5773*eps;
    float intensity = 0.01;
    vec3 p1 = pos * 10.5 + e.xyy;
    vec3 p2 = pos * 10.5 + e.yyx;
    vec3 p3 = pos * 10.5 + e.yxy;
    vec3 p4 = pos * 10.5 + e.xxx;
    float n1 = fbm(p1) * intensity;
    float n2 = fbm(p2) * intensity;
    float n3 = fbm(p3) * intensity;
    float n4 = fbm(p4) * intensity;
    return normalize( e.xyy*(map( pos + e.xyy ).x + n1) +
					  e.yyx*(map( pos + e.yyx ).x + n2) +
					  e.yxy*(map( pos + e.yxy ).x + n3) +
					  e.xxx*(map( pos + e.xxx ).x + n4) );
}

vec3 normal3( in vec3 pos, float eps )
{
    vec2 e = vec2(1.0,-1.0)*0.5773*eps;
    return normalize( e.xyy*(map( pos + e.xyy ).x) +
					  e.yyx*(map( pos + e.yyx ).x) +
					  e.yxy*(map( pos + e.yxy ).x) +
					  e.xxx*(map( pos + e.xxx ).x) );
}

void materialToProperty(vec3 p, vec2 mat, out vec3 baseColor, out vec3 normalVec) {
    baseColor = vec3(0.0);
    if (mat.y == MAT_INSIDE) {
        if (p.y < 0.0) {
            // floor
            floorProperty(p, mat, baseColor);
        } else {
            // ceil
            ceilProperty(p, mat, baseColor);
        }
    } else if (mat.y == MAT_OUTSIDE) {
        outsideProperty(p, mat, baseColor);
    } else if (mat.y == MAT_PILLAR) {
        pillarProperty(p, mat, baseColor);
    } else if (mat.y == MAT_BOARD) {
        boardProperty(p, mat, baseColor);
    } else if (mat.y == MAT_LIGHT) {
        baseColor = vec3(80.0);
    }
    normalVec = normal2(p, 0.0005);
}

void raymarch(vec3 origin, vec3 ray, int iter, out vec3 pos, out vec2 mat, out float t) {
    t = 0.01;
    vec3 col = vec3(0.0);
    int i;
    for(i=0; i<iter; i++) {
        pos = origin + ray * t;
        mat = map(pos);
        if (mat.x < 0.001) {
            break;
        }
        t += mat.x;
    }
}

vec3 shade(vec3 p, vec3 baseColor, float t) {
    p.x = abs(p.x) - 1.0;
    float attenuation = 1.0 / (pow(abs(p.x), 2.0) + pow(abs(p.y + 1.5), 2.0) + 6.0);
    vec3 col = baseColor * vec3(5.0) * attenuation;
    col = mix( col, vec3(0.0), 1.0-exp(-t*0.08) );
    return col;
}

float remap(float val, float inMin, float inMax, float outMin, float outMax)
{
    return clamp(outMin + (val - inMin) * (outMax - outMin) / (inMax - inMin), outMin, outMax);
}

vec3 shadeWithReflect(vec3 p, vec2 uv, vec3 baseColor, float t, vec3 n) {
    vec3 n2 = n - normal3(p, 0.0005);
    p.x = abs(p.x) - 1.0;
    float attenuation = 1.0 / (pow(abs(p.x), 2.0) + pow(abs(p.y + 1.5), 1.5) + 6.0);
    vec3 col = baseColor * vec3(5.0) * attenuation;
    
    float adjust = remap(1.0 - (t / 20.0), 0.0, 1.0, 0.1, 1.0);
    col += textureLod(reflectTexture, uv + n2.xz*adjust*0.5, 0.0).rgb * 0.05;
    col = mix( col, vec3(0.0), 1.0-exp(-t*0.04) );
    return col;
}

</script>

<script id="GBuffer" type="x-shader/x-fragment">
void mainImage( out vec4 fragColor, out vec4 fragColor2, in vec2 fragCoord ) {
    vec2 p = (fragCoord.xy * 2.0 - iResolution.xy) / min(iResolution.x, iResolution.y);
    vec2 uv = fragCoord.xy / iResolution.xy;
        
    if (abs(p.y) > 0.75) {
        return;
    }

    vec3 origin = vec3(sin(iTime*0.2) * 7.0, cos(iTime*0.05), -5.0 + iTime);
    vec3 target = vec3(0.0, 0.0, iTime);
    vec3 fo = normalize(target - origin);
    vec3 si = normalize(cross(vec3(0.0, 1.0, 0.0), fo));
    vec3 up = normalize(cross(fo, si));
    vec3 ray = normalize(fo * 3.5 + si * p.x + up * p.y);

    vec3 col, pos;
    vec2 d;
    float t;
    vec3 baseColor, n;
    raymarch(origin, ray, 128, pos, d, t);
    materialToProperty(pos, d, baseColor, n);

    fragColor  = vec4(n, t);
    fragColor2 = vec4(d, 1.0, pow(clamp(fbm(pos*2.0)*3.0, 0.0, 1.0), 10.0));
}

void main( )
{
    vec4 col, col2;
    mainImage(col, col2, gl_FragCoord.xy);
    fragColor  = col;
    fragColor2 = col2;
}
</script>

<script id="main" type="x-shader/x-fragment">
void mainImage( out vec4 fragColor, in vec2 fragCoord ) {
    vec2 p = (fragCoord.xy * 2.0 - iResolution.xy) / min(iResolution.x, iResolution.y);
    vec2 uv = fragCoord.xy / iResolution.xy;
        
    if (abs(p.y) > 0.75) {
        return;
    }

    vec3 origin = vec3(sin(iTime*0.2) * 7.0, cos(iTime*0.05), -5.0 + iTime);
    vec3 target = vec3(0.0, 0.0, iTime);
    vec3 fo = normalize(target - origin);
    vec3 si = normalize(cross(vec3(0.0, 1.0, 0.0), fo));
    vec3 up = normalize(cross(fo, si));
    vec3 ray = normalize(fo * 3.5 + si * p.x + up * p.y);

    vec3 col, pos;
    vec2 d;
    float t;
    vec3 baseColor, n;
    raymarch(origin, ray, 128, pos, d, t);
    materialToProperty(pos, d, baseColor, n);

    vec3 primaryCol = shadeWithReflect(pos, uv, baseColor, t, n);
    col = primaryCol;
    fragColor = vec4(col,1.0);
}

void main( )
{
    vec4 col;
    mainImage(col, gl_FragCoord.xy);
    fragColor = col;
}
</script>

<script id="mainReflect" type="x-shader/x-fragment">
void mainImage( out vec4 fragColor, in vec2 fragCoord ) {
    vec2 p = (fragCoord.xy * 2.0 - iResolution.xy) / min(iResolution.x, iResolution.y);
    vec2 uv = gl_FragCoord.xy / iResolution;
        
    if (abs(p.y) > 0.75) {
        return;
    }

    vec3 origin = vec3(sin(iTime*0.2) * 7.0, cos(iTime*0.05), -5.0 + iTime);
    vec3 target = vec3(0.0, 0.0, iTime);
    vec3 fo = normalize(target - origin);
    vec3 si = normalize(cross(vec3(0.0, 1.0, 0.0), fo));
    vec3 up = normalize(cross(fo, si));
    vec3 ray = normalize(fo * 3.5 + si * p.x + up * p.y);

    vec3 col, pos;
    vec2 d;
    float t;
    vec3 baseColor, n;
    vec4 depthNormal = textureLod(depthNormalTexture, uv, 0.0);
    vec4 matRoughness = textureLod(roughnessTexture, uv, 0.0);
    t = depthNormal.w;
    d = matRoughness.xy;
    pos = origin + ray * t;

    materialToProperty(pos, d, baseColor, n);

    n = normal3(pos, 0.005);
    vec3 r = reflect(ray, n);
    
    raymarch(pos + n*0.01, r, 128, pos, d, t);
    materialToProperty(pos, d, baseColor, n);
    
    vec3 secondaryCol = shade(pos, baseColor, t);
    
    col = secondaryCol;

    fragColor = vec4(col,1.0);
}

void main( )
{
    vec4 col;
    mainImage(col, gl_FragCoord.xy);
    fragColor = col;
}
</script>

<script id="fs" type="x-shader/x-fragment">
#version 300 es
precision highp float;
uniform vec2 fullResolution;
uniform vec2  resolution; 
uniform float time;
uniform sampler2D tex;

out vec4 fragColor;

void main( )
{
    vec2 p = (gl_FragCoord.xy*2.0-resolution)/resolution.y;
    vec2 uv = gl_FragCoord.xy / resolution;
    vec3 col = vec3(p, 0.5);
    vec2 rate = fullResolution / vec2(1024.0f);

    uv.y = 1.0 - uv.y;
    uv = uv * rate;

    col = textureLod(tex, clamp(uv, 0.0, 1.0), 0.0).rgb;
    fragColor=vec4(col,1);
}
</script>

<script id="combine" type="x-shader/x-fragment">
    #version 300 es
    precision highp float;
    uniform vec2  resolution;
    uniform sampler2D tex;
    uniform sampler2D bloomTex;
    out vec4 fragColor;

    float luminance(vec3 col)
    {
        return dot(vec3(0.298912, 0.586611, 0.114478), col);
    }
    
    vec3 saturation(vec3 col, float scale)
    {
        return mix(vec3(luminance(col)), col, scale);
    }
    
    vec3 contrast(vec3 col, float scale)
    {
        return (col - 0.5) * scale + 0.5;
    }
    
    vec3 colorCollect(vec3 col) {
        col = saturation(col, 0.5);
        col = pow(col, vec3(1.5));
        //col = contrast(col, 1.5);
        //col = col * vec3(1.0, 1.2, 1.5);
        //col = col * vec3(1.0, 1.5, 2.0);
        col = col * vec3(0.6, 0.9, 1.0);
        //col = col * vec3(0.7, 1.0, 0.8);
        return col;
    }

    vec3 acesFilm(const vec3 x) {
        const float a = 2.51;
        const float b = 0.03;
        const float c = 2.43;
        const float d = 0.59;
        const float e = 0.14;
        return clamp((x * (a * x + b)) / (x * (c * x + d ) + e), 0.0, 1.0);
    }

    // https://www.shadertoy.com/view/MdfBRX
    float Bokeh(vec2 p, vec2 sp, float size, float mi, float blur)
    {
        float d = length(p - sp);
        float c = smoothstep(size, size*(1.-blur), d);
        c *= mix(mi, 1., smoothstep(size*.8, size, d));
        return c;
    }
    
    vec2 hash( vec2 p ){
        p = vec2( dot(p,vec2(127.1,311.7)),dot(p,vec2(269.5,183.3)));
        return fract(sin(p)*43758.5453) * 2.0 - 1.0;
    }
    
    vec3 dirt(vec2 uv, float n)
    {
        vec2 p = fract(uv * n);
        vec2 st = (floor(uv * n) + 0.5) / n;
        vec2 rnd = hash(st);
        float c = Bokeh(p, vec2(0.5, 0.5) + vec2(0.3) * rnd, 0.2, abs(rnd.y * 0.4) + 0.3, 0.25 + rnd.x * rnd.y * 0.2);
        
        return vec3(c) * exp(rnd.x * 4.0);
    }
    
    vec3 dirtTexture(vec2 uv) {
        uv *= 2.5;
        vec3 di = vec3(0.0);
        di += dirt(uv - vec2(0.17), 60.0);
        di += dirt(uv - vec2(0.17), 30.0);
        di += dirt(uv - vec2(0.41), 100.75);
        di += dirt(uv - vec2(0.41), 20.75);
        return di * 0.01;
    }
    
    void main( )
    {
        vec2 p = (gl_FragCoord.xy*2.0-resolution)/resolution.y; 
        vec2 uv = gl_FragCoord.xy / resolution;
        vec3 col = vec3(0.0);

        if (abs(p.y) > 0.75) {
            fragColor=vec4(col,1);
            return;
        }

        vec3 bloom = textureLod(bloomTex, clamp(uv, 0.0, 1.0), 0.0).rgb;

        col = textureLod(tex, clamp(uv, 0.0, 1.0), 0.0).rgb + bloom;

        vec2 dirtuv = gl_FragCoord.xy / min(resolution.x, resolution.y);
        col +=  pow(bloom, vec3(1.5)) * dirtTexture(dirtuv);
        col = colorCollect(col);
        col = acesFilm(col*0.3);
        col = pow(col, vec3(1.0/2.2));
        //col = colorCollect(col);

        vec3 sclr = smoothstep(0.0, 1.0, col.rgb);

        col.r = mix(col.r, sclr.r, 1.0);
        col.g = mix(col.g, sclr.g, 0.8);
        col.b = mix(col.b, sclr.b, 0.6);

        //col = bloom*0.5;
        //col = vec3(textureLod(tex, clamp(uv, 0.0, 1.0), 0.0).rgb);
        

        fragColor=vec4(col,1);
    }
    </script>

<link rel="stylesheet" href="./style.css" />

<script type="text/javascript" src="http://ajax.googleapis.com/ajax/libs/webfont/1/webfont.js"></script>
<script type="text/javascript" src="./utility.js"></script>
<script type="text/javascript" src="./app.js"></script>

<html>
    <body>

    </body>
</html>