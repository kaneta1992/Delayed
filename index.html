<!DOCTYPE html>
<head>
<meta charset="utf-8"/>
</head>

<script id="main" type="x-shader/x-fragment">
#version 300 es
precision highp float;
uniform vec2 fullResolution;
uniform vec2  iResolution; 
uniform float iTime;
uniform sampler2D tex;

out vec4 fragColor;

#define MAT_INSIDE  0.
#define MAT_OUTSIDE 1.
#define MAT_PILLAR  2.
#define MAT_BOARD   3.
#define MAT_LIGHT   4.
float sphere(vec3 p, float s) {
    return length(p) - s;
}

float rBox( vec3 p, vec3 b, float r ){
  vec3 q = abs(p) - b;
  return length(max(q,0.0)) + min(max(q.x,max(q.y,q.z)),0.0) - r;
}

float cylinder(vec3 p, float r, float h) {
	float d = length(p.xz) - r;
    float clip = abs(p.y) - h;
    return max(d, clip);
}

vec3 boardOffset;
float boardDistance(vec3 p, vec3 offset) {
    boardOffset = offset;
    p -= offset;
    vec3 connectionPos = p;
    connectionPos.x = abs(connectionPos.x) - 0.5;
    connectionPos.y -= 2.0;
    
    float d = cylinder(connectionPos, 0.025, 2.0);
    d = min(d, rBox(p, vec3(0.8, 0.3, 0.05), 0.05));
    return d;
}

float lightsDistance(vec3 p) {
	p.z = mod(p.z + 3.0, 6.0) - 3.0;
    p.x = abs(p.x) - 1.0;
    float d = rBox(p, vec3(0.1, 0.001, 1.5), 0.02);
    return d;
}

vec2 min2(vec2 a, vec2 b) {
    return a.x < b.x ? a : b;
}

vec2 max2(vec2 a, vec2 b) {
    return a.x > b.x ? a : b;
}

vec2 map(vec3 p) {
    vec2 floorPos = p.xy;
    floorPos = abs(floorPos) - vec2(5.0, 1.5);
    vec2 flor = vec2(-max(floorPos.x, floorPos.y), MAT_INSIDE);
    
    vec3 pillarPos = p;
    pillarPos.x = abs(pillarPos.x) - 2.5;
    pillarPos.z = mod(pillarPos.z + 2.5, 5.0) - 2.5;
    vec2 pillar = vec2(rBox(pillarPos, vec3(0.2, 4.0, 0.2), 0.05), MAT_PILLAR);
    
    vec2 substractBoxPos = p.xy;
    substractBoxPos.x = abs(substractBoxPos.x) - 7.0;
    substractBoxPos = abs(substractBoxPos) - vec2(3.0, 4.0);
    vec2 substractBox = vec2(-max(substractBoxPos.x, substractBoxPos.y), MAT_OUTSIDE);
    
    vec2 d = min2(pillar, flor);
    d = max2(d, substractBox);
    
    vec3 boardPos = p;
    
    boardPos.z = mod(boardPos.z + 10.0, 20.0) - 10.0;
    vec2 board = vec2(boardDistance(boardPos, vec3(0.0, 1.0, 0.0)), MAT_BOARD);
    d = min2(d, board);
    
    p.y -= 1.5;
    vec2 lights = vec2(lightsDistance(p), MAT_LIGHT);
    
    d = min2(d, lights);
    
    return d;
}

void ceilProperty(vec3 p, vec2 mat, out vec3 baseColor) {
	p.z = mod(p.z + 0.15, 0.3) - 0.15;
    p.z = abs(p.z);
    float t = smoothstep(0.001, 0.006, p.z);
    baseColor = vec3(mix(vec3(0.2), vec3(0.3, 0.28, 0.25), t));
}

void floorProperty(vec3 p, vec2 mat, out vec3 baseColor) {
    vec2 latticePos = p.xz;
	latticePos = mod(latticePos + 0.15, 0.3) - 0.15;
    latticePos = abs(latticePos);
    float latticeAlpha = smoothstep(0.001, 0.006, min(latticePos.x, latticePos.y));
    
    vec2 blockPos = p.xz;
    blockPos.x = abs(blockPos.x) - 3.5; // block interval
    blockPos.x = abs(blockPos.x) - 0.2; // block width
    float blockAlpha = smoothstep(0.006, 0.001, blockPos.x);
    
    
    baseColor = vec3(mix(vec3(0.2), vec3(0.3, 0.28, 0.25), latticeAlpha));
    baseColor = vec3(mix(baseColor, vec3(0.6, 0.5, 0.1), blockAlpha));
}

void pillarProperty(vec3 p, vec2 mat, out vec3 baseColor) {
    vec3 pillarPos = p;
	pillarPos.y = mod(pillarPos.y + 0.4, 0.8) - 0.4;
    float d = abs(pillarPos.y);
    float pillarAlpha = smoothstep(0.001, 0.006, d);

    baseColor = vec3(mix(vec3(0.2), vec3(0.3, 0.28, 0.25), pillarAlpha));
}

void outsideProperty(vec3 p, vec2 mat, out vec3 baseColor) {
    baseColor = vec3(0.05, 0.02, 0.005);
}

void boardProperty(vec3 p, vec2 mat, out vec3 baseColor) {
	p -= boardOffset;
    vec2 displayPos = p.xy;
    displayPos.y = abs(displayPos.y + 0.08) - 0.1;
    displayPos = abs(displayPos) - vec2(0.7, 0.08);
    
    float d = max(displayPos.x, displayPos.y);
    float displayAlpha = smoothstep(0.006, 0.001, d);
    
    baseColor = mix(vec3(0.02), vec3(0.005), displayAlpha);
}

void materialToProperty(vec3 p, vec2 mat, out vec3 baseColor) {
    baseColor = vec3(0.0);
    if (mat.y == MAT_INSIDE) {
        if (p.y < 0.0) {
            // floor
            floorProperty(p, mat, baseColor);
        } else {
            // ceil
        	ceilProperty(p, mat, baseColor);
        }
    } else if (mat.y == MAT_OUTSIDE) {
        outsideProperty(p, mat, baseColor);
    } else if (mat.y == MAT_PILLAR) {
        pillarProperty(p, mat, baseColor);
    } else if (mat.y == MAT_BOARD) {
        boardProperty(p, mat, baseColor);
    } else if (mat.y == MAT_LIGHT) {
        baseColor = vec3(20.0);
    }
}

vec3 acesFilm(const vec3 x) {
    const float a = 2.51;
    const float b = 0.03;
    const float c = 2.43;
    const float d = 0.59;
    const float e = 0.14;
    return clamp((x * (a * x + b)) / (x * (c * x + d ) + e), 0.0, 1.0);
}

void mainImage( out vec4 fragColor, in vec2 fragCoord )
{
    vec2 p = (fragCoord.xy * 2.0 - iResolution.xy) / min(iResolution.x, iResolution.y);
    
    if (abs(p.y) > 0.75) {
    	return;
    }
    
    vec3 origin = vec3(sin(iTime*0.2) * 7.0, cos(iTime*0.05), -5.0 + iTime);
    vec3 target = vec3(0.0, 0.0, iTime);
    vec3 fo = normalize(target - origin);
    vec3 si = normalize(cross(vec3(0.0, 1.0, 0.0), fo));
    vec3 up = normalize(cross(fo, si));
    vec3 ray = normalize(fo * 3.5 + si * p.x + up * p.y);
    float t = 0.01;
    vec3 col = vec3(0.0), pos;
    vec2 d;
    int i;
    for(i=0; i<128; i++) {
    	pos = origin + ray * t;
        d = map(pos);
        if (d.x < 0.001) {
            break;
        }
        t += d.x;
    }
    
    vec3 baseColor;
    materialToProperty(pos, d, baseColor);

    pos.x = abs(pos.x) - 1.0;
    
    float attenuation = 1.0 / (pow(abs(pos.x), 2.0) + pow(abs(pos.y + 1.5), 2.0) + 6.0);
    col = baseColor * vec3(6.0) * attenuation;
    col = mix( col, vec3(0.0), 1.0-exp(-t*0.08) );
    
    
    //col = clamp(col, 0.0, 1.0);
    //col = max(vec3(0.0), col);
    
    col = acesFilm(col*0.5);
    col = pow(col, vec3(1.0/2.2));
    
    //col = colorCollect(col);
    
    

    fragColor = vec4(col,1.0);
}

void main( )
{
    vec4 col;
    mainImage(col, gl_FragCoord.xy);
    fragColor = col;
}
</script>

<script id="fs" type="x-shader/x-fragment">
#version 300 es
precision highp float;
uniform vec2 fullResolution;
uniform vec2  resolution; 
uniform float time;
uniform sampler2D tex;

out vec4 fragColor;

void main( )
{
    vec2 p = (gl_FragCoord.xy*2.0-resolution)/resolution.y;
    vec2 uv = gl_FragCoord.xy / resolution;
    vec3 col = vec3(p, 0.5);
    vec2 rate = fullResolution / vec2(1024.0f);

    uv.y = 1.0 - uv.y;
    uv = uv * rate;

    col = textureLod(tex, clamp(uv, 0.0, 1.0), 0.0).rgb;
    fragColor=vec4(col,1);
}
</script>

<script id="fs2" type="x-shader/x-fragment">
    #version 300 es
    precision highp float;
    uniform vec2  resolution;
    uniform sampler2D tex; 
    out vec4 fragColor;
    
    void main( )
    {
        vec2 uv = gl_FragCoord.xy / resolution;
        vec3 col = vec3(uv, 0.5);
        col = textureLod(tex, clamp(uv, 0.0, 1.0), 0.0).rgb;
        fragColor=vec4(col,1);
    }
    </script>

<link rel="stylesheet" href="./style.css" />

<script type="text/javascript" src="http://ajax.googleapis.com/ajax/libs/webfont/1/webfont.js"></script>
<script type="text/javascript" src="./utility.js"></script>
<script type="text/javascript" src="./app.js"></script>

<html>
    <body>

    </body>
</html>